//Shahriar Arefin

#include "optimized_WALKSAT.h"

// global variables
map<string, vector<int>> clauses_;
set<string> unsat_clause_;
int total_clauses;
int total_variables;

map<int, bool> walk_sat(float probability_, int max_flips) 
{
  //using map ADT for integer key and boolen value.
  map<int, bool> model; 
  //reseting the seed value to NULL for ranodom numbers
  srand(time(NULL)); 
  // assigning value T/F at random
  for (int i = 1; i < total_variables +1; i++)
  {
    int random_ = rand() % 2;
    if (random_ == 1)
    {
      model[i] = true;
    }
    else
    {
      model[i] = false;
    }
  }

  check_assigned_model(model, 0);

  int number_of_flips = 0;
  while (number_of_flips < max_flips)
  {
    if (unsat_clause_.empty())
    { 
      return model;
    } 

    auto iterator = unsat_clause_.begin();

    //Advances the iterator by random element positions.
    //choosing and unsat clause at random
    advance(iterator, rand()%unsat_clause_.size());
    vector<int> choosen_clause = clauses_[*iterator];

    //Using distribution to transform the random unsigned int generated by generator into a 
    // double between [0.0, 1.0).
    default_random_engine generator;
    uniform_real_distribution<double> distribution(0.0,1.0);

    int selected_variable;
    //Each call to distribution(generator) generates a new random double and check if its less than the probablity
    if (distribution(generator) < probability_) 
    {
      //pick a variable at random to flip
      int random_variable = choosen_clause[rand() % choosen_clause.size()];
      selected_variable = abs(random_variable);
    }
    else 
    {
      //flip the variable that maximizes the number of satisfied clauses overall
      int var;
      int least_unsat_count = total_clauses;
      for (int i = 0; i < choosen_clause.size(); i++) 
      {
        var = abs(choosen_clause[i]);
        int total_unsat_change = count_unsat_change(model, var);
        if (total_unsat_change < least_unsat_count){
          selected_variable = var;
          least_unsat_count = total_unsat_change;
        }
      }
    }
    model[selected_variable] = !model[selected_variable];
    check_assigned_model(model, selected_variable);

    number_of_flips++;
  }

  model.clear();  //If no solution found, return {0: false}
  model[0] = false;
  return model;
}
//loading CNF file 
void load_CNF_file(char* file_path) {
  string line;
  char DELIMITER = ' ';
  ifstream input_file(file_path); //
  if (input_file.is_open()) //Check that the file was opened.
  {
    getline(input_file, line); //ignore comment
    getline(input_file, line); //read the config
    vector<string> tokens = split_clause(line, DELIMITER);

    total_variables = stoi (tokens[2]);
    total_clauses = stoi (tokens[3]);

    for (int i = 0; i < total_clauses; i++) 
    {
      getline(input_file, line);
      tokens = split_clause(line, DELIMITER);
      vector<int> clause;
      for (int j = 0; j < tokens.size()-1; j++) 
      {
        clause.push_back( stoi(tokens[j]));
      }
      pair<string, vector<int>> entry;
      entry = make_pair(convert_clause_to_string(clause), clause);
      clauses_.insert(entry);
    }

    input_file.close();
  }
  else
  {
    cout << "Unable to open file, check filename is correct" << endl;
  }
}

void display_sat_model(const map<int, bool>& model) 
{
  vector<int> solution;
  for(map<int, bool>::const_iterator var = model.begin(); var != model.end(); ++var)
  {
    if (var->second == 1)
    {
      solution.push_back(var->first);
    }
    cout << var->first << " " << var->second << endl;
  }

  cout << "Therefore solution = " ;
  for (int i = 0; i < solution.size(); ++i)
  {
    cout << "X" << i+1 << ":" << solution[i] << ", ";
  }

  cout << endl;
}


bool verify_sat_model(const map<int, bool>& model) 
{
  for (auto i = clauses_.begin(); i != clauses_.end(); ++i) 
  {
    if (!if_correct_clause(i->second, model)) return false;
  }
  return true;
}


void check_assigned_model(const map<int, bool>& model, int symbol) 
{
  if (symbol != 0)
  {
    for (auto i = clauses_.begin(); i != clauses_.end(); ++i) 
    {
      if (if_symbol_exists(i->second, symbol)) 
      {
        if(if_correct_clause(i->second, model))
        {
          unsat_clause_.erase(i->first);
        }
        else 
        {
          unsat_clause_.insert(i->first);
        }
      }
    }
  }
  else
  {
    for (auto i = clauses_.begin(); i != clauses_.end(); ++i) 
    {
      if (!if_correct_clause(i->second, model)) 
      {
        unsat_clause_.insert(i->first);
      }
    }
  }
}

bool if_correct_clause(const vector<int>& clause, const map<int, bool>& model) 
{
  for(vector<int>::const_iterator i = clause.begin(); i != clause.end(); ++i)
  {
    if (((*i > 0) && (model.at(abs(*i)))) || ((*i < 0) && (!model.at(abs(*i))))) 
    {
      return true;
    }
  }
  return false;
}


int count_unsat_change(map<int, bool>& model, int variable)
{
  model[variable] = !model[variable]; //negate current value

  int change = 0;
  for (auto i = clauses_.begin(); i != clauses_.end(); ++i) 
  {
    if (if_symbol_exists(i->second, variable)) 
    {
      if(if_correct_clause(i->second, model) && (unsat_clause_.find(i->first) != unsat_clause_.end()))
      { 
        change--;
      }
      else if (!if_correct_clause(i->second, model) && (unsat_clause_.find(i->first) == unsat_clause_.end()))
      {
       change++;
      }
    }
  }
  model[variable] = !model[variable];
  return change;
}

bool if_symbol_exists(const vector<int>& clause, int symbol)
{
  for (int i = 0; i < clause.size(); i++) 
  {
    if (abs(clause[i]) == symbol)
    {
     return true;
    }
  }
  return false;
}

vector<string> split_clause(const string& string_, char delimiter) 
{
  vector<string> tokens;

  int start_index = 0;
  int word_length = 0;
  bool inword_ = false;

  for (int i = 0; i < string_.length(); i++) 
  {
    if (string_[i] == delimiter) {
      if (inword_ == true) 
      {
        string token = string_.substr(start_index, word_length);
        tokens.push_back(token);
      }
      start_index = i+1;
      word_length = 0;
      inword_ = false;
    }
    else 
    {
      word_length++;
      inword_ = true;
    }
  }
  if (inword_ == true)
  {
    tokens.push_back(string_.substr(start_index, word_length));
  }

  return tokens;
}

string convert_clause_to_string(const vector<int>& clause) 
{
  string encoding = "C";
  for (int i = 0; i < clause.size(); i++) 
  {
    encoding = encoding + " " + to_string(clause[i]);
  }
  return encoding;
}

